# 클로저(closure)란

클로저는 반환된 내부함수가 자신이 선언되었을 때의 환경인 스코프를 기억하며,  
만일 자신이 선언되었을 때의 환경(스코프) **밖에서 호출되어도 스코프에 접근**할 수 있는 함수를 말한다.

```javascript
function outerFunc() {
  var x = 10;
  var innerFunc = function () {
    console.log(x);
  };
  innerFunc();
}

outerFunc(); // 10
```

1. 함수 outerFunc의 내에서 내부함수 innerFunc가 선언되고 호출되었다.
2. 이때 내부함수 innerFunc는 자신을 포함하고 있는 외부함수 outerFunc의 변수 x에 접근할 수 있다.
3. 이는 innerFunc가 함수 outerFunc의 내부에 선언되었기 때문이다.

스코프는 함수를 호출할 때가 아니라 **함수를 어디에 선언**하였는지에 따라 결정된다.  
이를 **렉시컬 스코핑**이라고 한다.

내부함수 innerFunc를 함수 outerFunc 내에서 호출하는 것이 아니라 반환하게 해보면

```javascript
function outerFunc() {
  var x = 10;
  var innerFunc = function () {
    console.log(x);
  };
  return innerFunc;
}

/**
 *  함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다.
 *  그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다.
 */
var inner = outerFunc();
inner(); // 10
```

함수 outerFunc는 내부함수 innerFunc를 반환하고 없어졌다.  
즉, 함수 outerFunc는 실행된 이후 콜스택(실행 컨텍스트 스택)에서 제거되었으므로 함수 outerFunc의 변수 x 또한 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법은 없어보인다.

그러나 위 코드의 **실행결과는 변수 x의 값인 10**이다.  
이미 life cycle이 종료되어 실행 컨텍스트 스택에서 제거된 함수 outerFunc의 지역변수 x가 다시 부활이라도 한듯 동작하고 있다.

> 이처럼 **자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우**,  
> 외부 함수 밖에서 내부함수가 호출되더라도 **외부함수의 지역 변수에 접근**할 수 있는데  
> 이러한 함수를 클로져(Closure)라고 부르는 것이다.

---

## 클로져의 활용

### 상태유지

클로져가 가장 유용하게 사용되는 상황은 현재 상태를 기억하고 변경된 최신 상태를 유지하는 것이다.
만약 자바스크립트에 클로저라는 기능이 없다면 상태를 유지하기 위해 전역 변수를 사용할 수 밖에 없다.  
그러나 전역 변수는 언제든지 누구나 접근할 수 있고 변경할 수 있기 때문에 많은 부작용을 유발해 오류의 원인이 되므로 사용을 억제해야 한다.

### 전역 변수의 사용 억제

변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다.  
상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.
